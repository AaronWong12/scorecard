% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/perf.R
\name{perf_psi}
\alias{perf_psi}
\title{psi}
\usage{
perf_psi(label_train, score_train, label_test, score_test, type = c("psi",
  "score_distr"), title = "", positive = "bad|1", x_limits = c(100, 700),
  x_tick_break = 50, only_total = FALSE, seed = 186)
}
\arguments{
\item{label_train}{label values of training dataset, such as 0s and 1s.}

\item{score_train}{credit score of training dataset.}

\item{label_test}{label values of testing dataset, such as 0s and 1s.}

\item{score_test}{credit score of testing dataset.}

\item{type}{Plot of stability type, such as "psi", "score_distr". Default c("psi", "score_distr"), which means to export both psi and score distibution plot.}

\item{title}{Title of plot, default "".}

\item{positive}{Value of positive class, default "bad|1".}

\item{x_limits}{x-axis limits, default c(0, 800)}

\item{x_tick_break}{xaxis ticker break, default 100}

\item{only_total}{logical value, default FALSE, which means whether to show total score only.}

\item{seed}{An integer. The specify seed is used for random sorting data, default: 186.}
}
\value{
psi
}
\description{
\code{perf_psi} provides population stability index (PSI).
}
\examples{
# # Traditional Credit Scoring Using Logistic Regression
# # load germancredit data
# data("germancredit")
#
# # rename creditability as y
# dt <- data.table(germancredit)[, `:=`(
#   y = ifelse(creditability == "bad", 1, 0),
#   creditability = NULL
# )]
#
# # breaking dt into train and test ------
# set.seed(125)
# dt <- dt[sample(nrow(dt))]
# # rowname of train
# set.seed(345)
# rn <- sample(nrow(dt), nrow(dt)*0.6)
# # train and test dt
# dt_train <- dt[rn]; dt_test <- dt[-rn];
#
# # woe binning ------
# bins <- woebin(dt_train, "y")
#
# train <- woebin_ply(dt_train, bins)
# test <- woebin_ply(dt_test, bins)
#
# # glm ------
# m1 <- glm( y ~ ., family = "binomial", data = train)
# # summary(m1)
#
# # Select a formula-based model by AIC
# m_step <- step(m1, direction="both")
# m2 <- eval(m_step$call)
# # summary(m2)
#
# # performance ------
# # predicted proability
# train$pred <- predict(m2, type='response', train)
# test$pred <- predict(m2, type='response', test)
#
# # ks & roc plot
# perf_plot(train$y, train$pred, title = "train")
# perf_plot(train$y, train$pred, title = "test")
#
# # score
# card <- scorecard(bins, m2)
#
# # score
# train$score <- scorecard_ply(dt_train, card)
# test$score <- scorecard_ply(dt_test, card)
#
# # psi
# perf_psi(train$y, train$score, test$y, test$score,
#          x_limits = c(0, 700), x_tick_break = 100)
#
# perf_psi(c(train$y,test$y), c(train$score, test$score),
#                x_limits = c(0, 700), x_tick_break = 100)

}
